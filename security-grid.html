Complete Spy Puzzle Suite - First 3 Games
I'll create a complete, production-ready implementation with all 3 games connected. Here's the full code:
üìÅ File Structure
spy-puzzles/
‚îú‚îÄ‚îÄ index.html          (Mission briefing / hub)
‚îú‚îÄ‚îÄ security-grid.html  (Queens game)
‚îú‚îÄ‚îÄ decryption.html     (Sudoku game)
‚îú‚îÄ‚îÄ data-stream.html    (Zip game)
‚îú‚îÄ‚îÄ styles.css          (Shared styles)
‚îî‚îÄ‚îÄ mission-control.js  (Progress tracking)

1Ô∏è‚É£ index.html - Mission Hub
html<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Operation CLASSIFIED</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="hub">
  <div class="terminal-container">
    <div class="terminal-header">
      <span class="terminal-title">MI6 SECURE TERMINAL</span>
      <span class="terminal-status" id="status">ONLINE</span>
    </div>
    
    <div class="terminal-content">
      <div class="transmission">
        <p class="glitch" data-text=">>> INCOMING TRANSMISSION <<<">>>> INCOMING TRANSMISSION <<<</p>
        <p class="type-effect" id="briefing"></p>
      </div>

      <div class="mission-list" id="mission-list">
        <h2>ACTIVE MISSIONS</h2>
        
        <div class="mission-card" data-mission="security-grid">
          <div class="mission-status" id="status-1">‚è≥ PENDING</div>
          <h3>üéØ MISSION 01: SECURITY GRID</h3>
          <p>Deploy surveillance cameras to secure the perimeter. No two cameras can observe each other.</p>
          <button class="mission-btn" onclick="launchMission('security-grid.html')">DEPLOY</button>
          <div class="code-fragment" id="code-1" style="display:none;">
            <span>CODE FRAGMENT: <code>42</code></span>
          </div>
        </div>

        <div class="mission-card" data-mission="decryption">
          <div class="mission-status" id="status-2">üîí LOCKED</div>
          <h3>üîê MISSION 02: DECRYPTION MATRIX</h3>
          <p>Crack the encryption matrix. Complete the 4x4 grid following decryption protocols.</p>
          <button class="mission-btn" onclick="launchMission('decryption.html')" disabled id="btn-2">LOCKED</button>
          <div class="code-fragment" id="code-2" style="display:none;">
            <span>CODE FRAGMENT: <code>ALPHA</code></span>
          </div>
        </div>

        <div class="mission-card" data-mission="data-stream">
          <div class="mission-status" id="status-3">üîí LOCKED</div>
          <h3>üì° MISSION 03: DATA STREAM</h3>
          <p>Establish secure data connections. Link matching nodes without crossing paths.</p>
          <button class="mission-btn" onclick="launchMission('data-stream.html')" disabled id="btn-3">LOCKED</button>
          <div class="code-fragment" id="code-3" style="display:none;">
            <span>CODE FRAGMENT: <code>SIERRA</code></span>
          </div>
        </div>
      </div>

      <div class="final-section" id="final-section" style="display:none;">
        <div class="final-code-display">
          <h2>üéØ ALL MISSIONS COMPLETE</h2>
          <p>EXTRACTION CODE ASSEMBLED:</p>
          <div class="final-code" id="final-code">42-ALPHA-SIERRA</div>
          <p class="instruction">Use this code to unlock your gift! üéÅ</p>
        </div>
      </div>
    </div>
  </div>

  <script src="mission-control.js"></script>
  <script>
    // Type-writer effect for briefing
    const briefingText = `AGENT [CLASSIFIED],

Your mission, should you choose to accept it, involves recovering classified intelligence scattered across multiple secure systems.

Three critical systems must be breached:
1. SURVEILLANCE NETWORK
2. ENCRYPTION DATABASE  
3. DATA RELAY STATION

Each successful infiltration will yield a CODE FRAGMENT. Collect all three fragments to assemble the EXTRACTION CODE required to access your final objective.

Time is of the essence. Good luck, Agent.

This message will self-destruct in... just kidding. Get to work.

- M`;

    let i = 0;
    const briefingEl = document.getElementById('briefing');
    
    function typeWriter() {
      if (i < briefingText.length) {
        briefingEl.textContent += briefingText.charAt(i);
        i++;
        setTimeout(typeWriter, 20);
      }
    }

    // Start typing after page loads
    window.onload = () => {
      setTimeout(typeWriter, 1000);
      MissionControl.updateHub();
    };

    function launchMission(url) {
      // Glitch effect before transition
      document.body.classList.add('transition-glitch');
      setTimeout(() => {
        window.location.href = url;
      }, 500);
    }
  </script>
</body>
</html>

2Ô∏è‚É£ security-grid.html - Queens Game
html<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mission 01: Security Grid</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="game-screen">
  <div class="game-container">
    <div class="game-header">
      <button class="back-btn" onclick="window.location.href='index.html'">‚Üê ABORT MISSION</button>
      <h1>üéØ MISSION 01: SECURITY GRID</h1>
      <div class="timer" id="timer">00:00</div>
    </div>

    <div class="game-instructions">
      <h3>OBJECTIVE:</h3>
      <p>Deploy exactly <strong>6 surveillance cameras</strong> on the grid.</p>
      <p>‚ö†Ô∏è CONSTRAINTS:</p>
      <ul>
        <li>One camera per <strong>row</strong></li>
        <li>One camera per <strong>column</strong></li>
        <li>One camera per <strong>colored region</strong></li>
        <li>No two cameras can threaten each other (including diagonals)</li>
      </ul>
    </div>

    <div class="grid-container" id="grid-container"></div>

    <div class="game-controls">
      <button class="verify-btn" onclick="verifyGrid()">VERIFY SOLUTION</button>
      <button class="reset-btn" onclick="resetGrid()">RESET GRID</button>
    </div>

    <div class="result-display" id="result"></div>
  </div>

  <script src="mission-control.js"></script>
  <script>
    class SecurityGrid {
      constructor(size = 6) {
        this.size = size;
        this.regions = this.generateRegions();
        this.solution = [];
        this.generateSolution();
        this.cameras = new Set();
      }

      generateRegions() {
        // Create 6 irregular regions
        const regions = Array(36).fill(0);
        const regionSizes = Array(6).fill(0);
        const maxRegionSize = 6;

        // Start each region from a random seed
        const seeds = [];
        while (seeds.length < 6) {
          const seed = Math.floor(Math.random() * 36);
          if (!seeds.includes(seed)) seeds.push(seed);
        }

        // Flood fill from each seed
        seeds.forEach((seed, regionId) => {
          const queue = [seed];
          
          while (queue.length > 0 && regionSizes[regionId] < maxRegionSize) {
            const current = queue.shift();
            
            if (regions[current] !== 0) continue;
            
            regions[current] = regionId + 1;
            regionSizes[regionId]++;

            // Add unassigned neighbors
            const neighbors = this.getNeighbors(current);
            queue.push(...neighbors.filter(n => regions[n] === 0 && !queue.includes(n)));
          }
        });

        return regions;
      }

      getNeighbors(index) {
        const row = Math.floor(index / this.size);
        const col = index % this.size;
        const neighbors = [];

        if (row > 0) neighbors.push(index - this.size);
        if (row < this.size - 1) neighbors.push(index + this.size);
        if (col > 0) neighbors.push(index - 1);
        if (col < this.size - 1) neighbors.push(index + 1);

        return neighbors;
      }

      generateSolution() {
        // Backtracking to find valid camera placement
        const placed = [];
        const usedRows = new Set();
        const usedCols = new Set();
        const usedRegions = new Set();

        const backtrack = (regionId) => {
          if (regionId >= this.size) return true;

          const regionCells = this.regions
            .map((r, i) => r === regionId + 1 ? i : -1)
            .filter(i => i !== -1);

          // Shuffle for variety
          regionCells.sort(() => Math.random() - 0.5);

          for (const cell of regionCells) {
            const row = Math.floor(cell / this.size);
            const col = cell % this.size;

            if (usedRows.has(row) || usedCols.has(col)) continue;
            if (this.threatens(cell, placed)) continue;

            placed.push(cell);
            usedRows.add(row);
            usedCols.add(col);
            usedRegions.add(regionId);

            if (backtrack(regionId + 1)) return true;

            placed.pop();
            usedRows.delete(row);
            usedCols.delete(col);
            usedRegions.delete(regionId);
          }

          return false;
        };

        backtrack(0);
        this.solution = placed;
      }

      threatens(cell1, placedCameras) {
        const row1 = Math.floor(cell1 / this.size);
        const col1 = cell1 % this.size;

        for (const cell2 of placedCameras) {
          const row2 = Math.floor(cell2 / this.size);
          const col2 = cell2 % this.size;

          if (row1 === row2 || col1 === col2) return true;
          if (Math.abs(row1 - row2) === Math.abs(col1 - col2)) return true;
        }

        return false;
      }

      render() {
        const container = document.getElementById('grid-container');
        container.innerHTML = '';
        container.style.gridTemplateColumns = `repeat(${this.size}, 70px)`;

        for (let i = 0; i < this.size * this.size; i++) {
          const cell = document.createElement('div');
          cell.className = `grid-cell region-${this.regions[i]}`;
          cell.dataset.index = i;
          
          cell.onclick = () => this.toggleCamera(i);
          
          container.appendChild(cell);
        }
      }

      toggleCamera(index) {
        const cell = document.querySelector(`[data-index="${index}"]`);
        
        if (this.cameras.has(index)) {
          this.cameras.delete(index);
          cell.classList.remove('camera');
        } else {
          this.cameras.add(index);
          cell.classList.add('camera');
        }

        this.updateThreats();
      }

      updateThreats() {
        const cells = document.querySelectorAll('.grid-cell');
        cells.forEach(c => c.classList.remove('threatened', 'safe'));

        this.cameras.forEach(cam => {
          const row = Math.floor(cam / this.size);
          const col = cam % this.size;

          for (let i = 0; i < this.size * this.size; i++) {
            if (i === cam) continue;

            const r = Math.floor(i / this.size);
            const c = i % this.size;

            if (r === row || c === col || Math.abs(r - row) === Math.abs(c - col)) {
              cells[i].classList.add('threatened');
            }
          }
        });
      }

      verify() {
        if (this.cameras.size !== this.size) {
          return { success: false, message: `Need exactly ${this.size} cameras (currently ${this.cameras.size})` };
        }

        const rows = new Set();
        const cols = new Set();
        const regions = new Set();

        this.cameras.forEach(cam => {
          rows.add(Math.floor(cam / this.size));
          cols.add(cam % this.size);
          regions.add(this.regions[cam]);
        });

        if (rows.size !== this.size) {
          return { success: false, message: '‚ùå Must have one camera per row' };
        }
        if (cols.size !== this.size) {
          return { success: false, message: '‚ùå Must have one camera per column' };
        }
        if (regions.size !== this.size) {
          return { success: false, message: '‚ùå Must have one camera per colored region' };
        }

        // Check threats
        const camerasArray = Array.from(this.cameras);
        for (let i = 0; i < camerasArray.length; i++) {
          for (let j = i + 1; j < camerasArray.length; j++) {
            if (this.threatens(camerasArray[i], [camerasArray[j]])) {
              return { success: false, message: '‚ùå Two cameras are threatening each other!' };
            }
          }
        }

        return { success: true, message: '‚úÖ SECURITY GRID ESTABLISHED' };
      }
    }

    // Initialize game
    const game = new SecurityGrid(6);
    game.render();

    // Timer
    let startTime = Date.now();
    setInterval(() => {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
      const secs = (elapsed % 60).toString().padStart(2, '0');
      document.getElementById('timer').textContent = `${mins}:${secs}`;
    }, 1000);

    function verifyGrid() {
      const result = game.verify();
      const resultEl = document.getElementById('result');
      resultEl.textContent = result.message;
      resultEl.className = result.success ? 'result-display success' : 'result-display error';
      resultEl.style.display = 'block';

      if (result.success) {
        setTimeout(() => {
          MissionControl.completeMission('security-grid', '42');
          
          // Show success animation
          resultEl.innerHTML += '<br><br>üì° CODE FRAGMENT ACQUIRED: <code>42</code><br><br>Returning to base...';
          
          setTimeout(() => {
            window.location.href = 'index.html';
          }, 3000);
        }, 1000);
      }
    }

    function resetGrid() {
      game.cameras.clear();
      game.render();
      document.getElementById('result').style.display = 'none';
    }
  </script>
</body>
</html>
