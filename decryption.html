<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mission 02: Decryption Matrix</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="game-screen">
  <div class="game-container">
    <div class="game-header">
      <button class="back-btn" onclick="window.location.href='index.html'">‚Üê ABORT MISSION</button>
      <h1>üîê MISSION 02: DECRYPTION MATRIX</h1>
      <div class="timer" id="timer">00:00</div>
    </div>

    <div class="game-instructions">
      <h3>OBJECTIVE:</h3>
      <p>Complete the 4√ó4 decryption matrix.</p>
      <p>‚ö†Ô∏è RULES:</p>
      <ul>
        <li>Each <strong>row</strong> must contain 1, 2, 3, 4</li>
        <li>Each <strong>column</strong> must contain 1, 2, 3, 4</li>
        <li>Each <strong>2√ó2 box</strong> must contain 1, 2, 3, 4</li>
      </ul>
    </div>

    <div class="sudoku-grid" id="sudoku-grid"></div>

    <div class="game-controls">
      <button class="verify-btn" onclick="verifySolution()">VERIFY SOLUTION</button>
      <button class="reset-btn" onclick="resetPuzzle()">RESET PUZZLE</button>
    </div>

    <div class="result-display" id="result"></div>
  </div>

  <script src="mission-control.js"></script>
  <script>
    class DecryptionMatrix {
      constructor() {
        this.size = 4;
        this.grid = [];
        this.puzzle = [];
        this.generate();
      }

      generate() {
        // Generate completed grid
        this.grid = [
          [0, 0, 0, 0],
          [0, 0, 0, 0],
          [0, 0, 0, 0],
          [0, 0, 0, 0]
        ];

        this.fillGrid(0, 0);
        
        // Create puzzle by removing numbers
        this.puzzle = this.grid.map(row => [...row]);
        this.createPuzzle();
      }

      fillGrid(row, col) {
        if (row === this.size) return true;
        if (col === this.size) return this.fillGrid(row + 1, 0);

        const numbers = [1, 2, 3, 4].sort(() => Math.random() - 0.5);

        for (const num of numbers) {
          if (this.isValid(this.grid, row, col, num)) {
            this.grid[row][col] = num;
            if (this.fillGrid(row, col + 1)) return true;
            this.grid[row][col] = 0;
          }
        }

        return false;
      }

      isValid(grid, row, col, num) {
        // Check row
        if (grid[row].includes(num)) return false;

        // Check column
        for (let r = 0; r < this.size; r++) {
          if (grid[r][col] === num) return false;
        }

        // Check 2x2 box
        const boxRow = Math.floor(row / 2) * 2;
        const boxCol = Math.floor(col / 2) * 2;
        for (let r = boxRow; r < boxRow + 2; r++) {
          for (let c = boxCol; c < boxCol + 2; c++) {
            if (grid[r][c] === num) return false;
          }
        }

        return true;
      }

      createPuzzle() {
        // Remove 8 numbers strategically
        let toRemove = 8;
        const attempts = new Set();
        
        while (toRemove > 0 && attempts.size < 50) {
          const row = Math.floor(Math.random() * this.size);
          const col = Math.floor(Math.random() * this.size);
          const key = `${row}-${col}`;
          
          if (!attempts.has(key) && this.puzzle[row][col] !== 0) {
            this.puzzle[row][col] = 0;
            toRemove--;
            attempts.add(key);
          }
        }
      }

      render() {
        const container = document.getElementById('sudoku-grid');
        container.innerHTML = '';

        for (let r = 0; r < this.size; r++) {
          for (let c = 0; c < this.size; c++) {
            const cell = document.createElement('input');
            cell.type = 'number';
            cell.min = 1;
            cell.max = 4;
            cell.className = 'sudoku-cell';
            
            // Add box borders
            if (c === 1) cell.classList.add('box-right');
            if (r === 1) cell.classList.add('box-bottom');

            if (this.puzzle[r][c] !== 0) {
              cell.value = this.puzzle[r][c];
              cell.disabled = true;
              cell.classList.add('given');
            }

            cell.dataset.row = r;
            cell.dataset.col = c;
            
            cell.addEventListener('input', (e) => {
              if (e.target.value > 4) e.target.value = 4;
              if (e.target.value < 0) e.target.value = '';
              this.validateCell(r, c);
            });

            container.appendChild(cell);
          }
        }
      }

      validateCell(row, col) {
        const cell = document.querySelector(`input[data-row="${row}"][data-col="${col}"]`);
        const value = parseInt(cell.value) || 0;

        if (value === 0) {
          cell.style.background = '';
          return;
        }

        if (value === this.grid[row][col]) {
          cell.style.background = 'rgba(0, 255, 0, 0.2)';
        } else {
          cell.style.background = 'rgba(255, 0, 0, 0.2)';
        }
      }

      verify() {
        const cells = document.querySelectorAll('.sudoku-cell');
        let complete = true;
        let correct = true;

        cells.forEach(cell => {
          const row = parseInt(cell.dataset.row);
          const col = parseInt(cell.dataset.col);
          const value = parseInt(cell.value) || 0;

          if (value === 0) {
            complete = false;
          } else if (value !== this.grid[row][col]) {
            correct = false;
          }
        });

        if (!complete) {
          return { success: false, message: '‚ùå Matrix incomplete' };
        }
        if (!correct) {
          return { success: false, message: '‚ùå Errors detected in matrix' };
        }

        return { success: true, message: '‚úÖ DECRYPTION SUCCESSFUL' };
      }
    }

    // Initialize game
    const game = new DecryptionMatrix();
    game.render();

    // Timer
    let startTime = Date.now();
    setInterval(() => {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
      const secs = (elapsed % 60).toString().padStart(2, '0');
      document.getElementById('timer').textContent = `${mins}:${secs}`;
    }, 1000);

    function verifySolution() {
      const result = game.verify();
      const resultEl = document.getElementById('result');
      resultEl.textContent = result.message;
      resultEl.className = result.success ? 'result-display success' : 'result-display error';
      resultEl.style.display = 'block';

      if (result.success) {
        setTimeout(() => {
          MissionControl.completeMission('decryption', 'ALPHA');
          
          resultEl.innerHTML += '<br><br>üì° CODE FRAGMENT ACQUIRED: <code>ALPHA</code><br><br>Returning to base...';
          
          setTimeout(() => {
            window.location.href = 'index.html';
          }, 3000);
        }, 1000);
      }
    }

    function resetPuzzle() {
      game.puzzle = game.grid.map(row => [...row]);
      game.createPuzzle();
      game.render();
      document.getElementById('result').style.display = 'none';
    }
  </script>
</body>
</html>
