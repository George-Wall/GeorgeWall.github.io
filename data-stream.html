<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mission 03: Data Stream</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body class="game-screen">
  <div class="game-container">
    <div class="game-header">
      <button class="back-btn" onclick="window.location.href='index.html'">‚Üê ABORT MISSION</button>
      <h1>üì° MISSION 03: DATA STREAM</h1>
      <div class="timer" id="timer">00:00</div>
    </div>

    <div class="game-instructions">
      <h3>OBJECTIVE:</h3>
      <p>Connect matching numbered nodes with continuous paths.</p>
      <p>‚ö†Ô∏è RULES:</p>
      <ul>
        <li>Connect each pair of matching numbers</li>
        <li>Paths cannot cross each other</li>
        <li>Paths can only move horizontally or vertically</li>
        <li>The entire grid must be filled</li>
      </ul>
    </div>

    <canvas id="stream-canvas" width="420" height="420"></canvas>

    <div class="game-controls">
      <button class="verify-btn" onclick="verifyStream()">VERIFY CONNECTION</button>
      <button class="reset-btn" onclick="resetStream()">RESET STREAM</button>
      <button class="hint-btn" onclick="clearLastPath()">UNDO LAST PATH</button>
    </div>

    <div class="result-display" id="result"></div>
  </div>

  <script src="mission-control.js"></script>
  <script>
    class DataStream {
      constructor() {
        this.gridSize = 7;
        this.cellSize = 60;
        this.grid = Array(this.gridSize * this.gridSize).fill(0);
        this.endpoints = [];
        this.connections = [];
        this.drawing = null;
        this.occupied = new Set();
        
        this.canvas = document.getElementById('stream-canvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.generatePuzzle();
        this.setupInput();
        this.render();
      }

      generatePuzzle() {
        // Generate 3 pairs of endpoints
        const pairs = [
          { num: 1, color: '#ff6b6b' },
          { num: 2, color: '#4ecdc4' },
          { num: 3, color: '#ffe66d' }
        ];

        pairs.forEach(pair => {
          // Find two distant positions
          const [pos1, pos2] = this.findDistantPair();
          this.grid[pos1] = pair.num;
          this.grid[pos2] = pair.num;
          this.endpoints.push({ num: pair.num, positions: [pos1, pos2], color: pair.color });
        });
      }

      findDistantPair() {
        while (true) {
          const pos1 = Math.floor(Math.random() * (this.gridSize * this.gridSize));
          const pos2 = Math.floor(Math.random() * (this.gridSize * this.gridSize));

          if (this.grid[pos1] === 0 && this.grid[pos2] === 0 && pos1 !== pos2) {
            const row1 = Math.floor(pos1 / this.gridSize);
            const col1 = pos1 % this.gridSize;
            const row2 = Math.floor(pos2 / this.gridSize);
            const col2 = pos2 % this.gridSize;

            const distance = Math.abs(row1 - row2) + Math.abs(col1 - col2);
            
            if (distance >= 4) {
              return [pos1, pos2];
            }
          }
        }
      }

      setupInput() {
        let isDrawing = false;
        let lastCell = null;

        this.canvas.addEventListener('mousedown', (e) => {
          const cell = this.getCellFromEvent(e);
          if (cell !== null && this.grid[cell] > 0) {
            this.startDrawing(cell);
            isDrawing = true;
            lastCell = cell;
          }
        });

        this.canvas.addEventListener('mousemove', (e) => {
          if (!isDrawing || !this.drawing) return;
          
          const cell = this.getCellFromEvent(e);
          if (cell !== null && cell !== lastCell) {
            this.continueDrawing(cell);
            lastCell = cell;
          }
        });

        this.canvas.addEventListener('mouseup', (e) => {
          if (isDrawing && this.drawing) {
            const cell = this.getCellFromEvent(e);
            this.endDrawing(cell);
          }
          isDrawing = false;
          lastCell = null;
        });

        this.canvas.addEventListener('mouseleave', () => {
          if (isDrawing) {
            this.drawing = null;
            isDrawing = false;
            this.render();
          }
        });
      }

      getCellFromEvent(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const col = Math.floor(x / this.cellSize);
        const row = Math.floor(y / this.cellSize);
        
        if (row >= 0 && row < this.gridSize && col >= 0 && col < this.gridSize) {
          return row * this.gridSize + col;
        }
        return null;
      }

      startDrawing(cell) {
        const num = this.grid[cell];
        
        // Remove existing connection for this number
        this.connections = this.connections.filter(conn => {
          if (conn.num === num) {
            conn.path.forEach(c => this.occupied.delete(c));
            return false;
          }
          return true;
        });

        const endpoint = this.endpoints.find(e => e.num === num);
        this.drawing = {
          num: num,
          path: [cell],
          color: endpoint.color
        };
        this.render();
      }

      continueDrawing(cell) {
        const lastCell = this.drawing.path[this.drawing.path.length - 1];
        
        // Check if adjacent (no diagonals)
        const row1 = Math.floor(lastCell / this.gridSize);
        const col1 = lastCell % this.gridSize;
        const row2 = Math.floor(cell / this.gridSize);
        const col2 = cell % this.gridSize;
        
        const distance = Math.abs(row1 - row2) + Math.abs(col1 - col2);
        
        if (distance === 1) {
          // Check if cell is valid
          const isEndpoint = this.grid[cell] === this.drawing.num;
          const isOccupied = this.occupied.has(cell) && !this.drawing.path.includes(cell);
          
          if (!isOccupied || isEndpoint) {
            // Allow backtracking
            if (this.drawing.path.length > 1 && 
                this.drawing.path[this.drawing.path.length - 2] === cell) {
              this.drawing.path.pop();
            } else {
              this.drawing.path.push(cell);
            }
            this.render();
          }
        }
      }

      endDrawing(cell) {
        if (!this.drawing) return;

        const endpoint = this.endpoints.find(e => e.num === this.drawing.num);
        const targetPositions = endpoint.positions;
        
        // Check if we ended on the other endpoint
        if (targetPositions.includes(cell) && 
            cell !== this.drawing.path[0] &&
            this.drawing.path[this.drawing.path.length - 1] === cell) {
          
          // Valid connection!
          this.connections.push({...this.drawing});
          this.drawing.path.forEach(c => this.occupied.add(c));
        }

        this.drawing = null;
        this.render();
      }

      render() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw grid lines
        ctx.strokeStyle = '#2a2a2a';
        ctx.lineWidth = 1;
        for (let i = 0; i <= this.gridSize; i++) {
          ctx.beginPath();
          ctx.moveTo(i * this.cellSize, 0);
          ctx.lineTo(i * this.cellSize, this.gridSize * this.cellSize);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(0, i * this.cellSize);
          ctx.lineTo(this.gridSize * this.cellSize, i * this.cellSize);
          ctx.stroke();
        }

        // Draw connections
        this.connections.forEach(conn => {
          this.drawPath(conn.path, conn.color, 6);
        });

        // Draw current drawing
        if (this.drawing) {
          this.drawPath(this.drawing.path, this.drawing.color, 6, 0.7);
        }

        // Draw endpoints
        ctx.font = 'bold 24px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        this.endpoints.forEach(endpoint => {
          endpoint.positions.forEach(pos => {
            const row = Math.floor(pos / this.gridSize);
            const col = pos % this.gridSize;
            const x = col * this.cellSize + this.cellSize / 2;
            const y = row * this.cellSize + this.cellSize / 2;
            
            // Circle background
            ctx.fillStyle = endpoint.color;
            ctx.beginPath();
            ctx.arc(x, y, 18, 0, Math.PI * 2);
            ctx.fill();
            
            // Number
            ctx.fillStyle = '#000';
            ctx.fillText(endpoint.num, x, y);
          });
        });
      }

      drawPath(path, color, width, alpha = 1) {
        if (path.length < 2) return;

        const ctx = this.ctx;
        ctx.strokeStyle = color;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = width;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        ctx.beginPath();
        path.forEach((cell, i) => {
          const row = Math.floor(cell / this.gridSize);
          const col = cell % this.gridSize;
          const x = col * this.cellSize + this.cellSize / 2;
          const y = row * this.cellSize + this.cellSize / 2;

          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.stroke();
        ctx.globalAlpha = 1;
      }

      verify() {
        // Check all pairs connected
        if (this.connections.length !== this.endpoints.length) {
          return { 
            success: false, 
            message: `‚ùå Not all nodes connected (${this.connections.length}/${this.endpoints.length})` 
          };
        }

        // Check grid is completely filled
        const totalCells = this.gridSize * this.gridSize;
        if (this.occupied.size !== totalCells) {
          return { 
            success: false, 
            message: `‚ùå Grid not completely filled (${this.occupied.size}/${totalCells} cells)` 
          };
        }

        return { success: true, message: '‚úÖ DATA STREAM SECURED' };
      }
    }

    // Initialize game
    const game = new DataStream();

    // Timer
    let startTime = Date.now();
    setInterval(() => {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
      const secs = (elapsed % 60).toString().padStart(2, '0');
      document.getElementById('timer').textContent = `${mins}:${secs}`;
    }, 1000);

    function verifyStream() {
      const result = game.verify();
      const resultEl = document.getElementById('result');
      resultEl.textContent = result.message;
      resultEl.className = result.success ? 'result-display success' : 'result-display error';
      resultEl.style.display = 'block';

      if (result.success) {
        setTimeout(() => {
          MissionControl.completeMission('data-stream', 'SIERRA');
          
          resultEl.innerHTML += '<br><br>üì° CODE FRAGMENT ACQUIRED: <code>SIERRA</code><br><br>Returning to base...';
          
          setTimeout(() => {
            window.location.href = 'index.html';
          }, 3000);
        }, 1000);
      }
    }

    function resetStream() {
      game.connections = [];
      game.occupied.clear();
      game.drawing = null;
      game.render();
      document.getElementById('result').style.display = 'none';
    }

    function clearLastPath() {
      if (game.connections.length > 0) {
        const lastConnection = game.connections.pop();
        lastConnection.path.forEach(c => game.occupied.delete(c));
        game.render();
      }
    }
  </script>
</body>
</html>
