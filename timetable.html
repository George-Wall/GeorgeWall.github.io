<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Fitness Quest</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icon-192x192.png">
    <style>
        /* CSS Variables */
        :root {
            --safe-area-inset-top: env(safe-area-inset-top);
            --safe-area-inset-bottom: env(safe-area-inset-bottom);
            --background-color: #121212;
            --secondary-bg: #252525;
            --text-color: white;
            --accent-color: #8BC5BF;
            --accent-hover: #E4BAC1;
            --ios-bottom-safe-area: 34px;
            --warning-color: #ff4444;
            --upcoming-color: #4444ff;
            --success-color: #44ff44;
            --neutral-text: #8a8a8a;
            --xp-color: #FFD700;
            --attribute-strength: #ff7676;
            --attribute-endurance: #76ff76;
            --attribute-agility: #7676ff;
            --attribute-discipline: #ffff76;
            --attribute-resilience: #ff76ff;
        }

        /* Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            padding-top: calc(var(--safe-area-inset-top) + 10px);
            padding-bottom: calc(var(--safe-area-inset-bottom) + var(--ios-bottom-safe-area));
        }

        /* Layout */
        .container {
            max-width: 430px;
            margin: 0 auto;
            padding: 10px;
        }

        /* Header Styles */
        .header {
            background-color: var(--secondary-bg);
            padding: 16px;
            border-radius: 16px;
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .header-content {
            display: flex;
            flex-direction: column;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .character-level {
            font-size: 14px;
            color: var(--xp-color);
        }

        .points-display {
            background: rgba(255,255,255,0.1);
            padding: 8px 16px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .points-icon {
            color: var(--xp-color);
        }

        /* Character Stats Panel */
        .character-panel {
            background: linear-gradient(to right, var(--secondary-bg), #1a1a1a);
            border-radius: 16px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .xp-bar {
            background: rgba(255,255,255,0.1);
            height: 6px;
            border-radius: 3px;
            margin: 8px 0;
            overflow: hidden;
        }

        .xp-fill {
            height: 100%;
            background: var(--xp-color);
            transition: width 0.3s ease;
        }

        .attributes-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 12px;
        }

        .attribute-card {
            background: rgba(255,255,255,0.05);
            padding: 12px;
            border-radius: 8px;
        }

        .attribute-name {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 8px;
        }

        .attribute-bar {
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .attribute-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        /* Schedule Items */
        .schedule-item {
            background-color: var(--secondary-bg);
            padding: 16px;
            border-radius: 16px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            position: relative;
            transition: all 0.3s ease;
        }

        .schedule-item.completed {
            background-color: rgba(139, 197, 191, 0.1);
            transform: scale(0.98);
        }

        .checkbox {
            width: 24px;
            height: 24px;
            border: 2px solid var(--accent-color);
            border-radius: 50%;
            margin-right: 12px;
            position: relative;
        }

        .schedule-item.completed .checkbox::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background-color: var(--accent-color);
            border-radius: 50%;
        }

        const newStyles = `
    /* Floating Text Animations */
    .floating-text {
        position: fixed;
        pointer-events: none;
        animation: float-up 0.8s ease-out forwards;
        z-index: 1000;
        font-weight: bold;
        text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    .floating-text.xp {
        color: var(--xp-color);
    }

    .floating-text.attribute {
        color: var(--accent-color);
    }

    .floating-text.error {
        color: var(--warning-color);
    }

    @keyframes float-up {
        0% {
            opacity: 0;
            transform: translateY(20px);
        }
        10% {
            opacity: 1;
        }
        90% {
            opacity: 1;
        }
        100% {
            opacity: 0;
            transform: translateY(-20px);
        }
    }

    /* Modal Styles */
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0,0,0,0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000;
    }

    .modal-content {
        background-color: var(--secondary-bg);
        padding: 24px;
        border-radius: 16px;
        width: 90%;
        max-width: 400px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }

    .modal h3 {
        margin-bottom: 16px;
        font-size: 20px;
    }

    .modal-buttons {
        display: flex;
        gap: 12px;
        margin-top: 24px;
    }

    .modal button {
        flex: 1;
        padding: 12px;
        border: none;
        border-radius: 8px;
        font-weight: 500;
        cursor: pointer;
    }

    .confirm-button {
        background-color: var(--accent-color);
        color: var(--background-color);
    }

    .cancel-button {
        background-color: rgba(255,255,255,0.1);
        color: var(--text-color);
    }

    /* Rewards Shop Styles */
    .rewards-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
    }

    .rewards-categories {
        display: flex;
        gap: 8px;
        overflow-x: auto;
        padding: 4px 0 12px 0;
        margin: -4px 0;
    }

    .reward-category {
        background: rgba(255,255,255,0.1);
        border: none;
        padding: 8px 16px;
        border-radius: 20px;
        color: var(--text-color);
        white-space: nowrap;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .reward-category.active {
        background-color: var(--accent-color);
        color: var(--background-color);
    }

    .rewards-grid {
        display: grid;
        gap: 12px;
        margin-top: 16px;
    }

    .reward-item {
        background: rgba(255,255,255,0.05);
        padding: 16px;
        border-radius: 12px;
        display: flex;
        gap: 16px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .reward-item:hover {
        transform: translateY(-2px);
        background: rgba(255,255,255,0.08);
    }

    .reward-item.locked {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .reward-icon {
        font-size: 32px;
    }

    .reward-info {
        flex: 1;
    }

    .reward-name {
        font-weight: 500;
        margin-bottom: 4px;
    }

    .reward-description {
        font-size: 14px;
        color: var(--neutral-text);
        margin-bottom: 8px;
    }

    .reward-cost {
        display: flex;
        align-items: center;
        gap: 4px;
        color: var(--xp-color);
        font-weight: 500;
    }

    .cooldown {
        font-size: 12px;
        color: var(--warning-color);
        margin-top: 4px;
    }

    /* Achievement Animation */
    @keyframes achievement-slide {
        0% {
            transform: translateY(-100%);
            opacity: 0;
        }
        10% {
            transform: translateY(0);
            opacity: 1;
        }
        90% {
            transform: translateY(0);
            opacity: 1;
        }
        100% {
            transform: translateY(-100%);
            opacity: 0;
        }
    }

    /* Attribute Progress Bars */
    .attribute-progress {
        background: rgba(255,255,255,0.1);
        height: 4px;
        border-radius: 2px;
        overflow: hidden;
        margin-top: 4px;
    }

    .attribute-bar {
        height: 100%;
        transition: width 0.3s ease;
    }

    .attribute-bar.strength { background: linear-gradient(to right, #ff4d4d, #ff8080); }
    .attribute-bar.endurance { background: linear-gradient(to right, #4dff4d, #80ff80); }
    .attribute-bar.agility { background: linear-gradient(to right, #4d4dff, #8080ff); }
    .attribute-bar.discipline { background: linear-gradient(to right, #ffd700, #ffe44d); }
    .attribute-bar.resilience { background: linear-gradient(to right, #ff4dff, #ff80ff); }
`;

// Add styles to document
const styleSheet = document.createElement("style");
styleSheet.textContent = newStyles;
document.head.appendChild(styleSheet);

// Initialize the app when the document is ready
document.addEventListener('DOMContentLoaded', () => {
    App.initialize();
});
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-content">
                <h1 id="current-date">Today's Quest</h1>
                <div class="character-level">Level <span id="level">1</span> - <span id="character-title">Novice Athlete</span></div>
            </div>
            <div class="points-display">
                <span class="points-icon">‚ú®</span>
                <span id="points-amount">0</span>
            </div>
        </div>

        <div id="character-panel" class="character-panel" style="display: none;">
            <!-- Character stats will be populated by JS -->
        </div>

        <div id="daily-view">
            <div class="progress-section">
                <div class="progress-bar">
                    <div id="progress-fill" class="progress-fill"></div>
                </div>
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-number" id="completed-count">0</div>
                        <div class="stat-label">Completed</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="streak-count">0</div>
                        <div class="stat-label">Streak</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="level-count">1</div>
                        <div class="stat-label">Level</div>
                    </div>
                </div>
            </div>

            <div id="schedule-container">
                <!-- Schedule items will be populated by JS -->
            </div>
        </div>

        <div id="rewards-view" style="display: none;">
            <!-- Rewards shop will be populated by JS -->
        </div>
    </div>

    <div class="nav-buttons">
        <button class="nav-button active" onclick="UI.showView('daily')">
            <span class="nav-icon">üìã</span>
            <span>Today</span>
        </button>
        <button class="nav-button" onclick="UI.showView('character')">
            <span class="nav-icon">‚öîÔ∏è</span>
            <span>Character</span>
        </button>
        <button class="nav-button" onclick="UI.showView('rewards')">
            <span class="nav-icon">üéÅ</span>
            <span>Rewards</span>
        </button>
        <button class="nav-button" onclick="UI.showView('week')">
            <span class="nav-icon">üìÖ</span>
            <span>Week</span>
        </button>
    </div>

<script>
// Core Configurations
const CONFIG = {
    TIME: {
        UPCOMING_THRESHOLD: 30,
        GRACE_PERIOD: 15,
        CHECK_INTERVAL: 60000,
        SYNC_INTERVAL: 30000
    },
    TOUCH: {
        TAP_THRESHOLD: 10,
        SWIPE_THRESHOLD: 50,
        PULL_THRESHOLD: 100,
        MAX_PULL_DISTANCE: 150
    },
    HAPTIC: {
        LIGHT: 10,
        MEDIUM: [15, 15],
        HEAVY: [20, 20, 20]
    },
    ANIMATION: {
        CONFETTI_COUNT: 30,
        ACHIEVEMENT_DURATION: 3000,
        NUMBER_STEPS: 10
    }
};

    // Game Configuration
const GAMIFICATION_CONFIG = {
    XP_REWARDS: {
        TASK_COMPLETION: 100,
        ON_TIME_BONUS: 50,
        STREAK_MILESTONE: 500,
        PERFECT_DAY: 1000,
        WEEKLY_GOAL: 2000
    },
    ATTRIBUTE_GAINS: {
        GYM_WORKOUT: {
            strength: 2,
            discipline: 1
        },
        RUNNING: {
            endurance: 2,
            agility: 1
        },
        RECOVERY: {
            resilience: 2,
            discipline: 1
        },
        MOBILITY: {
            agility: 1,
            resilience: 1
        }
    },
    REWARDS: {
        FOOD: {
            PRETZEL: { 
                id: 'pretzel',
                name: "Favorite Pretzel",
                description: "Treat yourself to that pretzel you love",
                points: 500, 
                cooldown: 3 * 24 * 60 * 60 * 1000,
                icon: "ü•®"
            },
            COFFEE: { 
                id: 'coffee',
                name: "Coffee Shop Visit",
                points: 800, 
                cooldown: 4 * 24 * 60 * 60 * 1000,
                icon: "‚òï"
            },
            RESTAURANT: { 
                id: 'restaurant',
                name: "Restaurant Meal",
                points: 3000, 
                cooldown: 14 * 24 * 60 * 60 * 1000,
                icon: "üçΩÔ∏è"
            }
        },
        REST: {
            SLEEP_IN: { 
                id: 'sleep_in',
                name: "Sleep In Day",
                points: 1000, 
                cooldown: 7 * 24 * 60 * 60 * 1000,
                icon: "üò¥"
            },
            REST_DAY: { 
                id: 'rest_day',
                name: "Rest Day",
                points: 2500, 
                cooldown: 14 * 24 * 60 * 60 * 1000,
                icon: "üåü"
            }
        },
        SHOPPING: {
            SMALL_ITEM: { 
                id: 'small_item',
                name: "Online Shopping (¬£10)",
                points: 2000, 
                cooldown: 7 * 24 * 60 * 60 * 1000,
                icon: "üõçÔ∏è"
            }
        }
    },
    LEVEL_THRESHOLDS: {
        TITLES: {
            1: "Novice Athlete",
            5: "Dedicated Trainee",
            10: "Fitness Enthusiast",
            15: "Elite Performer",
            20: "Fitness Master",
            30: "Legendary Athlete"
        }
    }
};

// Schedule Configuration
const SCHEDULE_CONFIG = {
    TYPES: {
        1: { type: 'Gym Day', workout: 'A', color: '#8BC5BF', steps: '10,000', icon: 'üí™' },
        2: { type: 'Long Run Day', color: '#E4BAC1', steps: '10,000', icon: 'üèÉ' },
        3: { type: 'Gym Day', workout: 'B', color: '#8BC5BF', steps: '10,000', icon: 'üí™' },
        4: { type: 'Recovery Day', color: '#ffbb54', steps: '10,000', icon: 'üßò' },
        5: { type: 'Gym Day', workout: 'A', color: '#8BC5BF', steps: '10,000', icon: 'üí™' },
        6: { type: 'Fast Run Day', color: '#E4BAC1', steps: '10,000', icon: '‚ö°' },
        0: { type: 'Rest Day', color: '#808080', steps: '8,000', icon: 'üò¥' }
    },
    DAILY_SCHEDULES: {
        'Gym Day': [
            {time: '07:30', activity: 'Wake Up', details: '500ml water with electrolytes', icon: '‚è∞', type: 'RECOVERY'},
            {time: '07:35', activity: 'Morning Light', details: '10min outdoor exposure', icon: 'üåÖ', type: 'RECOVERY'},
            {time: '07:45', activity: 'Pre-Workout Snack', details: 'Light snack + caffeine', icon: 'ü•£', type: 'RECOVERY'},
            {time: '08:00', activity: 'Walk to Gym', details: '40min walking meditation', icon: 'üö∂', type: 'MOBILITY'},
            {time: '08:40', activity: 'Workout', details: '60min training session', icon: 'üí™', type: 'GYM_WORKOUT'},
            {time: '09:40', activity: 'Walk Home', details: '40min recovery walk', icon: 'üèÉ', type: 'MOBILITY'},
            {time: '10:20', activity: 'Cold Shower', details: '2-3min cold exposure', icon: 'üöø', type: 'RECOVERY'},
            {time: '10:30', activity: 'Post-Workout Meal', details: 'Protein + carbs', icon: 'üç≥', type: 'RECOVERY'},
            {time: '11:00', activity: 'Mobility Work', details: '15min recovery routine', icon: 'üßò', type: 'MOBILITY'}
        ],
        'Long Run Day': [
            {time: '07:30', activity: 'Wake Up', details: '500ml water', icon: '‚è∞', type: 'RECOVERY'},
            {time: '07:45', activity: 'Morning Light', details: '10min exposure', icon: 'üåÖ', type: 'RECOVERY'},
            {time: '08:00', activity: 'Light Snack', details: 'Simple carbs', icon: 'üçå', type: 'RECOVERY'},
            {time: '08:30', activity: 'Long Run', details: '45min steady state', icon: 'üèÉ', type: 'RUNNING'},
            {time: '09:15', activity: 'Cool Down Walk', details: '15min easy pace', icon: 'üö∂', type: 'MOBILITY'},
            {time: '09:45', activity: 'Recovery Meal', details: 'Balanced breakfast', icon: 'üç≥', type: 'RECOVERY'},
            {time: '10:15', activity: 'Mobility Work', details: '15min recovery routine', icon: 'üßò', type: 'MOBILITY'}
        ]
        // Other day types...
    }
};

// Game State Management
let gameState = {
    character: {
        level: 1,
        experience: 0,
        nextLevelXp: 1000,
        points: 0,
        attributes: {
            strength: 10,
            endurance: 10,
            agility: 10,
            discipline: 10,
            resilience: 10
        },
        achievements: [],
        title: 'Novice Athlete',
        streakBonus: 1.0
    },
    progress: {
        completedTasks: {},
        streaks: 0,
        lastCompletedDate: null,
        weeklyStats: {},
        lastSync: new Date().toISOString(),
        taskTimings: {}
    },
    rewards: {
        available: [],
        redeemed: [],
        cooldowns: {}
    }
};

// Core Game Systems
const GameSystems = {
    initialize() {
        // Load saved state
        const savedState = localStorage.getItem('gameState');
        if (savedState) {
            gameState = JSON.parse(savedState);
        }
        this.syncGameState();
    },

    syncGameState() {
        localStorage.setItem('gameState', JSON.stringify(gameState));
    },

    calculateNextLevelXp(level) {
        return Math.floor(1000 * Math.pow(1.5, level - 1));
    },

    awardExperience(amount, source = '') {
        const bonusXp = Math.floor(amount * gameState.character.streakBonus);
        gameState.character.experience += bonusXp;

        // Level up check
        while (gameState.character.experience >= gameState.character.nextLevelXp) {
            this.levelUp();
        }

        UI.updateExperienceBar();
        this.syncGameState();

        // Show XP gain notification
        UI.showFloatingText(`+${bonusXp} XP`, 'xp');
    },

    levelUp() {
        gameState.character.experience -= gameState.character.nextLevelXp;
        gameState.character.level++;
        gameState.character.nextLevelXp = this.calculateNextLevelXp(gameState.character.level);
        
        // Award level up bonus
        gameState.character.points += 500;
        
        // Update title if needed
        this.updateCharacterTitle();
        
        // Show level up celebration
        UI.showAchievement('Level Up! üéâ', 
            `You've reached level ${gameState.character.level}!\n+500 points bonus!`);
        
        UI.celebrate();
    },

    updateCharacterTitle() {
        const titles = GAMIFICATION_CONFIG.LEVEL_THRESHOLDS.TITLES;
        for (const [level, title] of Object.entries(titles).reverse()) {
            if (gameState.character.level >= parseInt(level)) {
                gameState.character.title = title;
                break;
            }
        }
    },
    GW
continue


I'll continue with more game systems and start the UI implementation:

javascript

Copy
    // Continue GameSystems...
    updateAttributes(activityType, multiplier = 1) {
        const gains = GAMIFICATION_CONFIG.ATTRIBUTE_GAINS[activityType];
        if (gains) {
            Object.entries(gains).forEach(([attribute, amount]) => {
                const oldValue = gameState.character.attributes[attribute];
                const gain = amount * multiplier;
                gameState.character.attributes[attribute] = Math.min(100, oldValue + gain);
                
                // Check for milestone (every 10 points)
                if (Math.floor(oldValue / 10) < Math.floor(gameState.character.attributes[attribute] / 10)) {
                    this.handleAttributeMilestone(attribute);
                }

                UI.showFloatingText(`+${gain} ${attribute}`, 'attribute');
            });
        }
        UI.updateAttributeBars();
        this.syncGameState();
    },

    handleAttributeMilestone(attribute) {
        const milestoneLevel = Math.floor(gameState.character.attributes[attribute] / 10) * 10;
        UI.showAchievement(
            `${attribute.charAt(0).toUpperCase() + attribute.slice(1)} Milestone!`,
            `Reached ${milestoneLevel} ${attribute}!\n+300 XP`
        );
        this.awardExperience(300, 'milestone');
    },

    redeemReward(rewardId) {
        const reward = this.getRewardById(rewardId);
        if (!reward) return false;

        if (this.canRedeemReward(rewardId)) {
            gameState.character.points -= reward.points;
            gameState.rewards.redeemed.push({
                id: rewardId,
                timestamp: Date.now()
            });
            gameState.rewards.cooldowns[rewardId] = Date.now() + reward.cooldown;
            
            UI.showAchievement('Reward Redeemed! üéÅ', 
                `You've redeemed: ${reward.name}`);
            
            this.syncGameState();
            return true;
        }
        return false;
    },

    canRedeemReward(rewardId) {
        const reward = this.getRewardById(rewardId);
        if (!reward) return false;

        // Check points
        if (gameState.character.points < reward.points) return false;

        // Check cooldown
        const cooldownEnd = gameState.rewards.cooldowns[rewardId] || 0;
        if (Date.now() < cooldownEnd) return false;

        return true;
    },

    getRewardById(rewardId) {
        for (const category of Object.values(GAMIFICATION_CONFIG.REWARDS)) {
            for (const reward of Object.values(category)) {
                if (reward.id === rewardId) return reward;
            }
        }
        return null;
    }
};

// UI System
const UI = {
    views: {
        daily: document.getElementById('daily-view'),
        character: document.getElementById('character-panel'),
        rewards: document.getElementById('rewards-view'),
        week: document.getElementById('week-view')
    },

    initialize() {
        this.setupViewTransitions();
        this.updateAll();
    },

    setupViewTransitions() {
        const buttons = document.querySelectorAll('.nav-button');
        buttons.forEach(button => {
            button.addEventListener('click', (e) => {
                buttons.forEach(b => b.classList.remove('active'));
                button.classList.add('active');
            });
        });
    },

    showView(viewName) {
        Object.entries(this.views).forEach(([name, element]) => {
            element.style.display = name === viewName ? 'block' : 'none';
        });

        // Special handling for each view
        switch(viewName) {
            case 'daily':
                this.updateDailyView();
                break;
            case 'character':
                this.updateCharacterView();
                break;
            case 'rewards':
                this.updateRewardsView();
                break;
            case 'week':
                this.updateWeekView();
                break;
        }
    },

    updateAll() {
        this.updateHeader();
        this.updateExperienceBar();
        this.updateAttributeBars();
        this.updateDailyView();
    },

    updateHeader() {
        document.getElementById('level').textContent = gameState.character.level;
        document.getElementById('character-title').textContent = gameState.character.title;
        document.getElementById('points-amount').textContent = gameState.character.points;
    },

    updateExperienceBar() {
        const percentage = (gameState.character.experience / gameState.character.nextLevelXp) * 100;
        document.querySelector('.xp-fill').style.width = `${percentage}%`;
        
        document.getElementById('current-xp').textContent = gameState.character.experience;
        document.getElementById('next-level-xp').textContent = gameState.character.nextLevelXp;
    },

    updateAttributeBars() {
        Object.entries(gameState.character.attributes).forEach(([attribute, value]) => {
            const bar = document.getElementById(`${attribute}-fill`);
            if (bar) {
                bar.style.width = `${value}%`;
            }
        });
    },

    updateDailyView() {
        const container = document.getElementById('schedule-container');
        container.innerHTML = ''; // Clear existing content

        const today = new Date();
        const schedule = this.getScheduleForDate(today);
        
        schedule.forEach((task, index) => {
            container.appendChild(this.createTaskElement(task, index));
        });
    },

    createTaskElement(task, index) {
        const element = document.createElement('div');
        element.className = `schedule-item ${this.getTaskStatus(task, index)}`;
        
        element.innerHTML = `
            <div class="checkbox"></div>
            <div class="task-content">
                <div class="task-time">${task.time}</div>
                <div class="task-title">${task.icon} ${task.activity}</div>
                <div class="task-details">${task.details}</div>
            </div>
            ${this.getTaskStatusIndicator(task, index)}
        `;

        element.addEventListener('click', () => this.handleTaskClick(task, index));
        
        return element;
    },

    getTaskStatus(task, index) {
        const dateStr = new Date().toLocaleDateString();
        const taskKey = `${index}-${dateStr}`;
        
        if (gameState.progress.completedTasks[dateStr]?.includes(taskKey)) {
            return 'completed';
        }

        const timeDiff = this.getTimeDifferenceInMinutes(task.time);
        if (timeDiff > CONFIG.TIME.GRACE_PERIOD) return 'overdue';
        if (timeDiff > -CONFIG.TIME.UPCOMING_THRESHOLD) return 'upcoming';
        
        return '';
    },

    getTaskStatusIndicator(task, index) {
        const status = this.getTaskStatus(task, index);
        if (!status) return '';

        const indicators = {
            completed: '‚úì Completed',
            overdue: '‚ö†Ô∏è Overdue',
            upcoming: '‚è≥ Coming up'
        };

        return `<div class="task-status ${status}">${indicators[status]}</div>`;
    },

    handleTaskClick(task, index) {
        const dateStr = new Date().toLocaleDateString();
        const taskKey = `${index}-${dateStr}`;
        
        if (!gameState.progress.completedTasks[dateStr]) {
            gameState.progress.completedTasks[dateStr] = [];
        }

        const isCompleted = gameState.progress.completedTasks[dateStr].includes(taskKey);
        
        if (isCompleted) {
            // Uncomplete task
            const taskIndex = gameState.progress.completedTasks[dateStr].indexOf(taskKey);
            gameState.progress.completedTasks[dateStr].splice(taskIndex, 1);
            this.handleTaskUncompletion(task);
        } else {
            // Complete task
            gameState.progress.completedTasks[dateStr].push(taskKey);
            this.handleTaskCompletion(task);
        }

        this.updateDailyView();
        GameSystems.syncGameState();
    },

    handleTaskCompletion(task) {
        // Base XP award
        GameSystems.awardExperience(GAMIFICATION_CONFIG.XP_REWARDS.TASK_COMPLETION, 'task');
        
        // Attribute gains
        GameSystems.updateAttributes(task.type);
        
        // Visual feedback
        this.celebrate();
        Utils.triggerHapticFeedback('medium');
    },

    celebrate() {
        const celebration = document.createElement('div');
        celebration.className = 'celebration';
        
        for (let i = 0; i < CONFIG.ANIMATION.CONFETTI_COUNT; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.setProperty('--delay', `${Math.random() * 500}ms`);
            confetti.style.setProperty('--rotation', `${Math.random() * 360}deg`);
            confetti.style.left = `${Math.random() * 100}%`;
            celebration.appendChild(confetti);
        }
        
        document.body.appendChild(celebration);
        setTimeout(() => celebration.remove(), 2000);
    },
    GW
continue


I'll continue with more game systems and start the UI implementation:

javascript

Copy
    // Continue GameSystems...
    updateAttributes(activityType, multiplier = 1) {
        const gains = GAMIFICATION_CONFIG.ATTRIBUTE_GAINS[activityType];
        if (gains) {
            Object.entries(gains).forEach(([attribute, amount]) => {
                const oldValue = gameState.character.attributes[attribute];
                const gain = amount * multiplier;
                gameState.character.attributes[attribute] = Math.min(100, oldValue + gain);
                
                // Check for milestone (every 10 points)
                if (Math.floor(oldValue / 10) < Math.floor(gameState.character.attributes[attribute] / 10)) {
                    this.handleAttributeMilestone(attribute);
                }

                UI.showFloatingText(`+${gain} ${attribute}`, 'attribute');
            });
        }
        UI.updateAttributeBars();
        this.syncGameState();
    },

    handleAttributeMilestone(attribute) {
        const milestoneLevel = Math.floor(gameState.character.attributes[attribute] / 10) * 10;
        UI.showAchievement(
            `${attribute.charAt(0).toUpperCase() + attribute.slice(1)} Milestone!`,
            `Reached ${milestoneLevel} ${attribute}!\n+300 XP`
        );
        this.awardExperience(300, 'milestone');
    },

    redeemReward(rewardId) {
        const reward = this.getRewardById(rewardId);
        if (!reward) return false;

        if (this.canRedeemReward(rewardId)) {
            gameState.character.points -= reward.points;
            gameState.rewards.redeemed.push({
                id: rewardId,
                timestamp: Date.now()
            });
            gameState.rewards.cooldowns[rewardId] = Date.now() + reward.cooldown;
            
            UI.showAchievement('Reward Redeemed! üéÅ', 
                `You've redeemed: ${reward.name}`);
            
            this.syncGameState();
            return true;
        }
        return false;
    },

    canRedeemReward(rewardId) {
        const reward = this.getRewardById(rewardId);
        if (!reward) return false;

        // Check points
        if (gameState.character.points < reward.points) return false;

        // Check cooldown
        const cooldownEnd = gameState.rewards.cooldowns[rewardId] || 0;
        if (Date.now() < cooldownEnd) return false;

        return true;
    },

    getRewardById(rewardId) {
        for (const category of Object.values(GAMIFICATION_CONFIG.REWARDS)) {
            for (const reward of Object.values(category)) {
                if (reward.id === rewardId) return reward;
            }
        }
        return null;
    }
};

// UI System
const UI = {
    views: {
        daily: document.getElementById('daily-view'),
        character: document.getElementById('character-panel'),
        rewards: document.getElementById('rewards-view'),
        week: document.getElementById('week-view')
    },

    initialize() {
        this.setupViewTransitions();
        this.updateAll();
    },

    setupViewTransitions() {
        const buttons = document.querySelectorAll('.nav-button');
        buttons.forEach(button => {
            button.addEventListener('click', (e) => {
                buttons.forEach(b => b.classList.remove('active'));
                button.classList.add('active');
            });
        });
    },

    showView(viewName) {
        Object.entries(this.views).forEach(([name, element]) => {
            element.style.display = name === viewName ? 'block' : 'none';
        });

        // Special handling for each view
        switch(viewName) {
            case 'daily':
                this.updateDailyView();
                break;
            case 'character':
                this.updateCharacterView();
                break;
            case 'rewards':
                this.updateRewardsView();
                break;
            case 'week':
                this.updateWeekView();
                break;
        }
    },

    updateAll() {
        this.updateHeader();
        this.updateExperienceBar();
        this.updateAttributeBars();
        this.updateDailyView();
    },

    updateHeader() {
        document.getElementById('level').textContent = gameState.character.level;
        document.getElementById('character-title').textContent = gameState.character.title;
        document.getElementById('points-amount').textContent = gameState.character.points;
    },

    updateExperienceBar() {
        const percentage = (gameState.character.experience / gameState.character.nextLevelXp) * 100;
        document.querySelector('.xp-fill').style.width = `${percentage}%`;
        
        document.getElementById('current-xp').textContent = gameState.character.experience;
        document.getElementById('next-level-xp').textContent = gameState.character.nextLevelXp;
    },

    updateAttributeBars() {
        Object.entries(gameState.character.attributes).forEach(([attribute, value]) => {
            const bar = document.getElementById(`${attribute}-fill`);
            if (bar) {
                bar.style.width = `${value}%`;
            }
        });
    },

    updateDailyView() {
        const container = document.getElementById('schedule-container');
        container.innerHTML = ''; // Clear existing content

        const today = new Date();
        const schedule = this.getScheduleForDate(today);
        
        schedule.forEach((task, index) => {
            container.appendChild(this.createTaskElement(task, index));
        });
    },

    createTaskElement(task, index) {
        const element = document.createElement('div');
        element.className = `schedule-item ${this.getTaskStatus(task, index)}`;
        
        element.innerHTML = `
            <div class="checkbox"></div>
            <div class="task-content">
                <div class="task-time">${task.time}</div>
                <div class="task-title">${task.icon} ${task.activity}</div>
                <div class="task-details">${task.details}</div>
            </div>
            ${this.getTaskStatusIndicator(task, index)}
        `;

        element.addEventListener('click', () => this.handleTaskClick(task, index));
        
        return element;
    },

    getTaskStatus(task, index) {
        const dateStr = new Date().toLocaleDateString();
        const taskKey = `${index}-${dateStr}`;
        
        if (gameState.progress.completedTasks[dateStr]?.includes(taskKey)) {
            return 'completed';
        }

        const timeDiff = this.getTimeDifferenceInMinutes(task.time);
        if (timeDiff > CONFIG.TIME.GRACE_PERIOD) return 'overdue';
        if (timeDiff > -CONFIG.TIME.UPCOMING_THRESHOLD) return 'upcoming';
        
        return '';
    },

    getTaskStatusIndicator(task, index) {
        const status = this.getTaskStatus(task, index);
        if (!status) return '';

        const indicators = {
            completed: '‚úì Completed',
            overdue: '‚ö†Ô∏è Overdue',
            upcoming: '‚è≥ Coming up'
        };

        return `<div class="task-status ${status}">${indicators[status]}</div>`;
    },

    handleTaskClick(task, index) {
        const dateStr = new Date().toLocaleDateString();
        const taskKey = `${index}-${dateStr}`;
        
        if (!gameState.progress.completedTasks[dateStr]) {
            gameState.progress.completedTasks[dateStr] = [];
        }

        const isCompleted = gameState.progress.completedTasks[dateStr].includes(taskKey);
        
        if (isCompleted) {
            // Uncomplete task
            const taskIndex = gameState.progress.completedTasks[dateStr].indexOf(taskKey);
            gameState.progress.completedTasks[dateStr].splice(taskIndex, 1);
            this.handleTaskUncompletion(task);
        } else {
            // Complete task
            gameState.progress.completedTasks[dateStr].push(taskKey);
            this.handleTaskCompletion(task);
        }

        this.updateDailyView();
        GameSystems.syncGameState();
    },

    handleTaskCompletion(task) {
        // Base XP award
        GameSystems.awardExperience(GAMIFICATION_CONFIG.XP_REWARDS.TASK_COMPLETION, 'task');
        
        // Attribute gains
        GameSystems.updateAttributes(task.type);
        
        // Visual feedback
        this.celebrate();
        Utils.triggerHapticFeedback('medium');
    },

    celebrate() {
        const celebration = document.createElement('div');
        celebration.className = 'celebration';
        
        for (let i = 0; i < CONFIG.ANIMATION.CONFETTI_COUNT; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.setProperty('--delay', `${Math.random() * 500}ms`);
            confetti.style.setProperty('--rotation', `${Math.random() * 360}deg`);
            confetti.style.left = `${Math.random() * 100}%`;
            celebration.appendChild(confetti);
        }
        
        document.body.appendChild(celebration);
        setTimeout(() => celebration.remove(), 2000);
    },
    // App Initialization
const App = {
    async initialize() {
        // Load saved state
        GameSystems.initialize();
        UI.initialize();

        // Set up service worker for PWA
        if ('serviceWorker' in navigator) {
            try {
                await navigator.serviceWorker.register('/service-worker.js');
            } catch (error) {
                console.error('Service worker registration failed:', error);
            }
        }

        // Set up notifications
        if ('Notification' in window && Notification.permission === 'default') {
            await Notification.requestPermission();
        }

        // Set up periodic checks
        setInterval(() => this.checkSchedule(), CONFIG.TIME.CHECK_INTERVAL);
        setInterval(() => this.syncData(), CONFIG.TIME.SYNC_INTERVAL);

        // Initialize first view
        UI.showView('daily');
    },

    checkSchedule() {
        const now = new Date();
        const todaySchedule = SCHEDULE_CONFIG.DAILY_SCHEDULES[this.getCurrentScheduleType()];
        
        todaySchedule.forEach((task, index) => {
            const taskTime = Utils.parseTime(task.time);
            const diff = (taskTime - now) / 1000 / 60; // minutes

            if (diff <= CONFIG.TIME.UPCOMING_THRESHOLD && diff > 0) {
                this.notifyUpcoming(task);
            }
        });
    },

    getCurrentScheduleType() {
        const dayOfWeek = new Date().getDay();
        return SCHEDULE_CONFIG.TYPES[dayOfWeek].type;
    },

    notifyUpcoming(task) {
        if (Notification.permission === 'granted') {
            const notification = new Notification('Upcoming Task', {
                body: `${task.activity} starts in ${Math.round(diff)} minutes`,
                icon: '/icon-192x192.png'
            });
        }
    },

    syncData() {
        GameSystems.syncGameState();
    }
};
